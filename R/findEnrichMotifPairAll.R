#' Finds all combinations of enriched motif pairs in a given
#' genomic regions.
#'
#' @param target_data A data frame containing peaks coordinates with chr, start,
#' and end as first three columns
#' @param background_data Same as "target_data"
#' @param genome_ver Genome version, it should be either "hg19" or "hg38"
#' @param scramble_data A logical value (TRUE/FALSE) whether background data
#' need to be generated by scrambling target_data, by default FALSE
#' @param motif_database A character representing motif database to choose from,
#' it should be one of c("JASPAR", "ENCODE", "CISBP", "HOMER") default = "CISBP"
#' @param Pvalue_computation A character representing P value computations are
#' either based on binomial or hyper geometric distributions, it should be one
#' of c("binom", "hyper"), default = "hyper"
#' @param Pvalue_threshold A numeric value for filtering the enriched motifs and
#' motif pairs
#' @param Pvalue_adjust_method A character representing method for adjustig the
#' P values for multple comparisons, it should be one or more of
#' c("holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr", "none")
#' default = "BH"
#' @return A data frame containing enriched motif pairs with P-values,
#' fold-enrichment and annotations
#' @examples
#' \dontrun{
#' findEnrichMotifPairAll(target_data, background_data = NULL,
#' genome_ver = "hg38", scramble_data = TRUE)
#' }
#' @import stats
#' @importFrom motifmatchr matchMotifs
#' @importFrom GenomicRanges makeGRangesFromDataFrame
#' @importFrom rlang .data
#' @importFrom SummarizedExperiment assays
#' @importFrom dplyr inner_join
#' @importFrom dplyr %>%
#' @importFrom assertthat assert_that
#' @export
#'
#'
findEnrichMotifPairAll = function(target_data, background_data = NULL,
                               genome_ver = "hg38", scramble_data = TRUE,
                               motif_database = "JASPAR",
                               Pvalue_computation = "hyper",
                               Pvalue_threshold = 0.05,
                               Pvalue_adjust_method = "BH"){
    # checking input data and parameters
    assertthat::assert_that(is.data.frame(target_data))
    assertthat::assert_that(is.character(genome_ver))
    assertthat::assert_that(is.logical(scramble_data))
    assertthat::assert_that(is.character(motif_database))
    assertthat::assert_that(is.character(Pvalue_computation))
    assertthat::assert_that(is.numeric(Pvalue_threshold))
    assertthat::assert_that(is.character(Pvalue_adjust_method))

    # loading the right genome based on user choice
    if(genome_ver == "hg19"){
        genome_data <- BSgenome.Hsapiens.UCSC.hg19::BSgenome.Hsapiens.UCSC.hg19
    } else {genome_data <- BSgenome.Hsapiens.UCSC.hg38::BSgenome.Hsapiens.UCSC.hg38}

    # checking if background data is provided by user
    if(is.null(background_data) & !scramble_data){
        bg_gr <- generateBackgroundSeqs(input_data = target_data,
                                        genome_ver = genome_ver)
        message("background data is generated by matched GC, length and chromosome distribution")
    } else {message("background data is provided by the user or generated by scrambling the input sequences")}
    
    if(is.null(background_data) & scramble_data){
        bg_gr <- generateScrambleSeqs(input_data = target_data,
                                      genome_ver = genome_ver)
        message("background data is generated by scrambling the input sequences")
    }
    
    # convert data into GRanges objects
    if(!is.null(background_data) & !scramble_data){
        bg_gr <- background_data %>% GenomicRanges::makeGRangesFromDataFrame(keep.extra.columns = TRUE, ignore.strand = TRUE)
    }
    
    message("Check point 1 passed")
    tg_gr <- target_data %>% GenomicRanges::makeGRangesFromDataFrame(keep.extra.columns = TRUE, ignore.strand = TRUE)
    message("Check point 2 passed")
    # extract relevant motifs PWM and their annotation based on motif database
    filter_col <- function(df1, col_name, val) {
        col_name <- dplyr::enquo(col_name) # captures the environment in which the function was called
        df1 %>% dplyr::filter((!!col_name) %in% val)
    }

    filter_col2 <- function(df1, col_name, val) {
        col_name <- dplyr::enquo(col_name) # captures the environment in which the function was called
        df1 %>% dplyr::filter((!!col_name) == val)
    }

    motif_anno <- filter_col(motif_anno_data, .data$motif_source, motif_database)
    #motif_anno <- base::subset(motif_anno_data, motif_source == motif_database)
    message("Check point 3 passed")
    idx <- base::match(motif_anno[,1], names(all_motifs))
    message("Check point 4 passed")
    motifs_PWMs <- all_motifs[idx]
    message("Check point 5 passed")

    # find motif locations
    motif_ix_scores_tg <- motifmatchr::matchMotifs(motifs_PWMs, tg_gr, out = "scores", genome = genome_data)
    motif_ix_scores_bg <- motifmatchr::matchMotifs(motifs_PWMs, bg_gr, out = "scores", genome = genome_data)
    message("Check point 6 passed")

    f1 <- SummarizedExperiment::assays(motif_ix_scores_tg)$motifMatches
    f2 <- SummarizedExperiment::assays(motif_ix_scores_bg)$motifMatches
    # save(f1, f2, file = "tt1.rda")
    # compute P-value and Fold enrichment
    motif_pval <- function(tg2 = f1, bg2 = f2, Pval_dist = "binom"){
        tg_mf_c1 <- data.frame(motif_name = colnames(tg2), tg_motif_count = Matrix::colSums(tg2), row.names = NULL, stringsAsFactors = FALSE)
        bg_mf_c1 <- data.frame(motif_name = colnames(bg2), bg_motif_count = Matrix::colSums(bg2), row.names = NULL, stringsAsFactors = FALSE)

        tg_bg_mf_c <- dplyr::inner_join(tg_mf_c1, bg_mf_c1)
        tg_bg_mf_c$fold_enrich <- ((tg_bg_mf_c$tg_motif_count + 0)/(dim(tg2)[1] + 0))/((tg_bg_mf_c$bg_motif_count + 0)/(dim(bg2)[1] + 0))

        # computes P-values based on binomial distribution
        compute_pval_binom <- function(data1 = data1, tot_tg = dim(tg2)[1], tot_bg = dim(bg2)[1]){
            return(binom.test(x = data1[1], n = tot_tg, p = data1[2]/tot_bg, alternative = "greater")$p.value)
        }

        # computes P-values based on hypergeometric distribution or fisher's exact test
        compute_pval_hyper <- function(data1 = data1, tot_tg = dim(tg2)[1], tot_bg = dim(bg2)[1]){
            return(phyper(q = data1[1]-1, m = (data1[1] + data1[2]), n = (tot_tg + tot_bg) - (data1[1] + data1[2]), k = tot_tg, lower.tail = FALSE, log.p = FALSE))
        }

        if(Pval_dist == "binom"){
            tg_bg_mf_c$pval <- apply(X = tg_bg_mf_c[,2:3], MARGIN = 1, FUN = compute_pval_binom, tot_tg = dim(tg2)[1], tot_bg = dim(bg2)[1])
        } else (tg_bg_mf_c$pval <- apply(X = tg_bg_mf_c[,2:3], MARGIN = 1, FUN = compute_pval_hyper, tot_tg = dim(tg2)[1], tot_bg = dim(bg2)[1]))
        return(tg_bg_mf_c)
    }

    # motif_enrich <- motif_pval(tg2 = f1, bg2 = f2, Pval_dist = "hyper")
    # motif_enrich <- dplyr::inner_join(motif_enrich, motif_anno[, 1:2])
    # motif_enrich <- motif_enrich[, c(1,6,2:5)] %>% dplyr::filter(.data$log_pval < -6.907755)
    # message("Check point 8 passed")
    # data_res2 <- motif_enrich #%>% dplyr::filter(.data$log_pval < -6.907755)

    data_2motif <- NULL
    # k = 1
    for (k in 1:dim(f1)[2]){
        #m1 <- data_res2$motif_name[k]
        #idx_m <- match(m1, colnames(f1))

        # find motifs with same fold enrichment
        #fold_val <- data_res2$fold_enrich[k]
        #motif_similar <- filter_col(data_res2, .data$fold_enrich, fold_val)
        #idx_sm <- match(motif_similar$motif_name, colnames(f1))

        f1_1 <- f1[f1[,k], -k]
        f2_1 <- f2[f2[,k], -k]

        data_2motif_temp <- motif_pval(tg2 = f1_1, bg2 = f2_1, Pval_dist = Pvalue_computation)
        data_2motif_temp$pval_adj <- p.adjust(data_2motif_temp$pval, method = Pvalue_adjust_method)
        data_2motif_temp$motif_name_1 <- colnames(f1)[k]
        data_2motif_temp <- data_2motif_temp %>% dplyr::arrange(pval_adj)
        data_2motif <- rbind(data_2motif, data_2motif_temp)
    }
    data_2motif_1 <- dplyr::inner_join(data_2motif, motif_anno[, 1:2], by = c("motif_name_1" = "motif_name"))
    colnames(data_2motif_1)[c(1,8)] <- c("motif_name_2", "TF_name_1")
    data_2motif_2 <- dplyr::inner_join(data_2motif_1, motif_anno[, 1:2], by = c("motif_name_2" = "motif_name"))
    # re-arrange the columns
    data_2motif_3 <- data_2motif_2[, c(7,8,1,9,4,5,6)]
    colnames(data_2motif_3)[4] <- "TF_name_2"
    data_2motif_4 <- data_2motif_3 %>% dplyr::filter(.data$pval_adj < Pvalue_threshold)

    # get rid off the inf values if any
    data_2motif_4 <- data_2motif_4 %>% dplyr::filter_if(~is.numeric(.), dplyr::all_vars(!is.infinite(.)))

    # remove duplicate pairs
    removeDuplicatePairs <- function(data = data_2motif_4){
        data <- data %>% dplyr::mutate(forward = paste0(motif_name_1, sep = "_", motif_name_2), reverse = paste0(motif_name_2, sep = "_", motif_name_1))
        # get the unique pairs
        data1 <- data %>% dplyr::filter(!(forward %in% reverse))
        data2 <- data %>% dplyr::filter((forward %in% reverse)) %>% dplyr::arrange(forward)
        data2_1 <-data2[1:(nrow(data2)/2), ]
        data3 <- rbind(data1, data2_1)
        data3$forward <- NULL
        data3$reverse <- NULL
        return(data3)
    }
    data_2motif_5 <- removeDuplicatePairs(data = data_2motif_4)
    motif_pair_enrich_all <- data_2motif_5
    # save(motif_pair_enrich_all, file = "results.rda")
    return(motif_pair_enrich_all)
    #return(motif_anno)
}




